<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title>requestIdleCallback, Let the browser work for you! · Justin on WEB</title><meta name="description" content="requestIdleCallback, Let the browser work for you! - Justin Willis"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/MyBlog/favicon.png"><link rel="stylesheet" href="/MyBlog/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://jgw96.github.io/MyBlog/atom.xml" title="Justin on WEB"></head><body><div class="wrap"><header><a href="/MyBlog/" class="logo-link"><img src="/MyBlog/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/MyBlog/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/MyBlog/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/jgw96" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/MyBlog/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">requestIdleCallback, Let the browser work for you!</h1><div class="post-info">Jan 11, 2017</div><div class="post-content"><p>By now you have probably heard of RequestAnimationFrame, if not the tldr is that RequestAnimationFrame lets the browser time<br>animations for you to line up perfectly with the painting process, meaning you get more performant animations. This is a perfect example<br>letting the platform work for you, and therefore gaining better performance since the browser can be smart about the whole thing. Since your<br>PWA’s are going to be running mainly in a mobile environment, where computation resources are very limited, the more we can let the<br>browser help us be fast, the better off we will be. A newer example of an api that lets the browser help us that you may not have heard of yet is<br><code>requestIdleCallback</code>. Lets dive into this new api and see how it can help make your next PWA lightning fast!</p>
<h4 id="What-exactly-is-requestIdleCallback"><a href="#What-exactly-is-requestIdleCallback" class="headerlink" title="What exactly is requestIdleCallback?"></a>What exactly is requestIdleCallback?</h4><p><code>requestIdleCallback</code> is a new api that lets the browser execute code when it is idle. In this case idle means that the browser is currently<br>at the end of a frame, has some free time and that the user is not interacting with the app in any way. <code>requestIdleCallback</code> will only fire<br>the function passed to it when these two requirements are met, which does mean that if it does not have any idle time it may not actually<br>execute the function passed to it. While this may sound like a bad thing, <em>Hey I wrote this code, execute it damnit</em> , <code>requestIdleCallback</code><br>has some handy features that we will see below to let you ensure that a bit of code is executed if it has to be.</p>
<h4 id="Use-Cases"><a href="#Use-Cases" class="headerlink" title="Use Cases"></a>Use Cases</h4><p>Before we go into examples of how to use <code>requestIdleCallback</code> I thought I would introduce some instances where this new api comes in handy.<br>First, most big sites and PWA’s use analytics of some kind so that the developer of that site can know how their users use this app. Now,<br>imagine if your on a mobile device (and remember, not everyone has that brand new Google Pixel or Iphone 7), click on a menu and boom,<br>that analaytics service kicks off some javascript to send the event to the analytics server. What happens when thread blocking JS<br>runs when the browser is trying to animate? Jank, and sometimes lots of it. Now imagine that the developer used <code>requestIdleCallback</code> to<br>send that analytics request. With <code>requestIdleCallback</code> the browser would have waited until it was idle (no painting or animating) and then<br>would have sent the analytics request while it was idle. Now we have a jank free experience and still get to send those analytics! Second,<br>imagine that we have a PWA that processes audio data using the Web Audio api. On mobile devices this can potentially be heavy on the<br>cpu and do some thread locking. If we timed this work using <code>requestIdleCallback</code> the browser could then help us do this heavy work while<br>the browser is idle and keep our PWA silky smooth!</p>
<h4 id="One-last-thing-before-we-use-this-api"><a href="#One-last-thing-before-we-use-this-api" class="headerlink" title="One last thing before we use this api"></a>One last thing before we use this api</h4><p>As with all newer api’s we should always remember to fall back gracefully to older ways of doing things on browsers that do not yet support<br>certain api’s. Current browser support for <code>requestIdleCallback</code> is as follows:</p>
<ul>
<li>Chrome: Fully supported, available in Chrome since Chrome 47 (current stable version of Chrome is Chrome 55)</li>
<li>Firefox: Coming in Firefox 52 (current stable version of Firefox is Firefox 50)</li>
<li>Edge: <a href="https://developer.microsoft.com/en-us/microsoft-edge/platform/status/requestidlecallback/" target="_blank" rel="external">Under consideration</a></li>
<li>Opera: Fully supported as of Opera 42 (current stable version of Opera is Opera 42)</li>
<li>Safari: Not supported, unfortunately could not find any info on when Safari plans to support <code>requestIdleCallback</code></li>
</ul>
<p>To test for <code>requestIdleCallback</code> suppport in your code and fall back gracefully for browsers with no support you can use this<br>pattern.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (<span class="string">'requestIdleCallback'</span> <span class="keyword">in</span> <span class="built_in">window</span>) &#123;</div><div class="line">  requestIdleCallback(doHeavyComputation)</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">  <span class="comment">// No support so lets just execute our code</span></div><div class="line">  doHeavyComputation()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>With this code we will use <code>requestIdleCallback</code> when it is available and simply fall back to just executing our code when<br>there is no support for it in the browser our app is running on.</p>
<h4 id="Ok-so-how-do-I-use-this-thing"><a href="#Ok-so-how-do-I-use-this-thing" class="headerlink" title="Ok, so how do I use this thing?"></a>Ok, so how do I use this thing?</h4><p>If you have ever used RequestAnimationFrame then the <code>requestIdleCallback</code> api should feel pretty familiar to you. To use <code>requestIdleCallback</code><br>the first step is to pass it a callback. Our callback should be the function that we would like to schedule for idle time, <code>doHeavyComputation</code> in this example.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">requestIdleCallback(doHeavyComputation);</div></pre></td></tr></table></figure>
<p>In a nutshell this is all you really need to use <code>requestIdleCallback</code>, but this usage does not guarantee that your code will be executed<br>and also does not let you know how much time is actually available for that specific call to <code>requestIdleCallback</code> so lets expand on this<br>example a little. The function that gets called by <code>requestIdleCallback</code> will receive a <code>deadline</code> object as a paramater. This <code>deadline</code><br>object offers some pretty handy information.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// function were passing to requestIdleCallback</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">doHeavyComputation</span>(<span class="params">deadline</span>) </span>&#123;</div><div class="line">  <span class="keyword">while</span> (deadline.timeRemaining &gt; <span class="number">0</span>) &#123;</div><div class="line">    <span class="comment">// do work while we have time</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">20000000</span>; i++) &#123;</div><div class="line">      amazinglyHugeArray.push(&#123;<span class="attr">fact</span>: <span class="string">'JS is cool'</span>&#125;);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// we ran out of time, schedule again</span></div><div class="line">  requestIdleCallback(doHeavyComputation)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>In this example we are using the <code>deadline</code> object to check if we have time left. While we do have free time we will do our heavy computation.<br>The cool thing here is that if we run out of time doing this work then we can simply schedule another <code>requestIdleCallback</code> and try again next<br>time the browser is idle. Now, say we want to ensure that some code will be ran even if <code>requestIdleCallback</code> runs out of time. <code>requestIdleCallback</code><br>takes a second paramater which lets us set a timeout. This forces the browser to finish executing our code by the time the timeout is reached. Now<br>before I even show an example of this I would like to stress that you should only do this if you <em>really</em> <em>really</em> need to. The whole point<br>of using <code>requestIdleCallback</code> is to schedule execution of code while the browser is idle so that we do not jank our PWA and it is definitely<br>possible that when the timeout is reached the browser may still be busy, which means that executing our code may jank the world. So now that<br>you are thoroughly warned about releasing the jank monster lets see an example of timeout in action.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">requestIdleCallback(doHeavyComputation, &#123; <span class="attr">timeout</span>: <span class="number">3000</span> &#125;);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">doHeavyComputation</span>(<span class="params">deadline</span>) </span>&#123;</div><div class="line">  <span class="keyword">while</span> (deadline.timeRemaining &gt; <span class="number">0</span> || deadline.didTimeout) &#123;</div><div class="line">    <span class="comment">// do work while we have time</span></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">20000000</span>; i++) &#123;</div><div class="line">      amazinglyHugeArray.push(&#123;<span class="attr">fact</span>: <span class="string">'JS is cool'</span>&#125;);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>As you can see here, we are now also checking for <code>deadline.didTimeout</code>. <code>didTimeout</code> will be <code>true</code> when our timeout has been reached which means<br>that even though the browser has ran out of idle time we are still going to execute our code. Again, this can release the jank monster so be careful.</p>
<h4 id="What-does-this-have-to-do-with-my-PWA"><a href="#What-does-this-have-to-do-with-my-PWA" class="headerlink" title="What does this have to do with my PWA ?"></a>What does this have to do with my PWA ?</h4><p>One of the big “selling points” of PWA’s is that they are able to be very light on resources and give an awesome experience on even the lowest of low end devices.<br>The problem here is even if we have done everything else that a good PWA should do perf wise (fast load time, cache resources for even faster load time next load etc etc),<br>if we execute javascript while the app is animating then we give our user a janky, slow experience, and who likes jank and slowness right? By taking advantage of perf oriented<br>API’s like like <code>requestIdleCallback</code> we can let the platform our PWA’s all run on, the browser, help us succeed in our perf goals!</p>
<p>Hope you enjoyed this post! Make sure to tune in next time to learn about devices api’s and why they are important for PWA’s!</p>
</div></article></div></main><footer><div class="paginator"><a href="/MyBlog/2017/01/02/Started/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2017 <a href="https://jgw96.github.io/MyBlog">Justin Willis</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>